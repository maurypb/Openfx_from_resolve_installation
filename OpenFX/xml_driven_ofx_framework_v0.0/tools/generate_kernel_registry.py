#!/usr/bin/env python3
"""
Kernel Registry Generator for XML-driven OFX Framework

Scans the effects/ folder for XML files and generates a C++ registry
of all kernel functions for dynamic dispatch.
"""

import os
import sys
import xml.etree.ElementTree as ET
from pathlib import Path

def scan_effects_folder(effects_dir="effects"):
    """Scan effects folder for XML files and extract effect information"""
    effects = []
    
    if not os.path.exists(effects_dir):
        print(f"ERROR: Effects directory '{effects_dir}' not found")
        return effects
    
    for xml_file in Path(effects_dir).glob("*.xml"):
        print(f"Processing: {xml_file}")
        
        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            
            if root.tag != 'effect':
                print(f"  WARNING: Skipping {xml_file} - not an effect definition")
                continue
            
            effect_name = root.get('name')
            if not effect_name:
                print(f"  WARNING: Skipping {xml_file} - no effect name")
                continue
            
            # Check for CUDA kernel
            cuda_kernel = None
            kernels_section = root.find('kernels')
            if kernels_section is not None:
                cuda_node = kernels_section.find('cuda')
                if cuda_node is not None:
                    cuda_kernel = cuda_node.get('file')
            
            if cuda_kernel:
                function_name = f"call_{effect_name.lower()}_kernel"
                effects.append({
                    'name': effect_name,
                    'xml_file': str(xml_file),
                    'cuda_file': cuda_kernel,
                    'function_name': function_name
                })
                print(f"  ✓ Found effect: {effect_name} → {function_name}")
            else:
                print(f"  WARNING: No CUDA kernel found for {effect_name}")
                
        except ET.ParseError as e:
            print(f"  ERROR: XML parse error in {xml_file}: {e}")
        except Exception as e:
            print(f"  ERROR: Failed to process {xml_file}: {e}")
    
    return effects

def generate_registry_header(effects):
    """Generate KernelRegistry.h"""
    header_content = """#ifndef KERNEL_REGISTRY_H
#define KERNEL_REGISTRY_H

#include <string>

/**
 * @brief Auto-generated kernel registry for XML-driven OFX framework
 * 
 * This file is generated by generate_kernel_registry.py
 * DO NOT EDIT MANUALLY - changes will be overwritten
 */

// Kernel function type
typedef void (*KernelFunction)(
    void* stream, int width, int height,
    void* texture1, void* texture2, bool present1,
    void* texture3, bool present2,
    float* output,
    float param1, float param2, int param3, float param4
);

/**
 * @brief Get kernel function by effect name
 * @param effectName Name from XML effect definition
 * @return Function pointer or nullptr if not found
 */
KernelFunction getKernelFunction(const std::string& effectName);

/**
 * @brief Get number of registered effects
 * @return Number of effects in registry
 */
int getRegisteredEffectCount();

/**
 * @brief Get effect name by index
 * @param index Index in registry
 * @return Effect name or empty string if invalid index
 */
std::string getEffectName(int index);

#endif // KERNEL_REGISTRY_H
"""
    return header_content

def generate_registry_implementation(effects):
    """Generate KernelRegistry.cpp"""
    
    # Generate forward declarations
    forward_decls = []
    for effect in effects:
        forward_decls.append(f"extern \"C\" void {effect['function_name']}(")
        forward_decls.append("    void* stream, int width, int height,")
        forward_decls.append("    void* texture1, void* texture2, bool present1,")
        forward_decls.append("    void* texture3, bool present2,")
        forward_decls.append("    float* output,")
        forward_decls.append("    float param1, float param2, int param3, float param4")
        forward_decls.append(");")
        forward_decls.append("")
    
    # Generate registry table
    registry_entries = []
    for i, effect in enumerate(effects):
        registry_entries.append(f"    {{ \"{effect['name']}\", {effect['function_name']} }},")
    
    # Generate effect names array
    effect_names = []
    for effect in effects:
        effect_names.append(f"    \"{effect['name']}\",")
    
    impl_content = f"""#include "KernelRegistry.h"
#include <map>
#include <vector>

/**
 * @brief Auto-generated kernel registry for XML-driven OFX framework
 * 
 * Generated from effects folder containing {len(effects)} effect(s):
"""
    
    for effect in effects:
        impl_content += f" * - {effect['name']} ({effect['xml_file']})\n"
    
    impl_content += """ * 
 * This file is generated by generate_kernel_registry.py
 * DO NOT EDIT MANUALLY - changes will be overwritten
 */

// Forward declarations for all kernel functions
""" + "\n".join(forward_decls) + f"""

// Registry structure
struct KernelEntry {{
    const char* effectName;
    KernelFunction function;
}};

// Auto-generated registry table
static const KernelEntry kernelRegistry[] = {{
""" + "\n".join(registry_entries) + f"""
}};

static const int registrySize = {len(effects)};

// Effect names for index lookup
static const char* effectNames[] = {{
""" + "\n".join(effect_names) + f"""
}};

KernelFunction getKernelFunction(const std::string& effectName) {{
    for (int i = 0; i < registrySize; ++i) {{
        if (effectName == kernelRegistry[i].effectName) {{
            return kernelRegistry[i].function;
        }}
    }}
    return nullptr;
}}

int getRegisteredEffectCount() {{
    return registrySize;
}}

std::string getEffectName(int index) {{
    if (index >= 0 && index < registrySize) {{
        return std::string(effectNames[index]);
    }}
    return std::string();
}}
"""
    
    return impl_content

def main():
    print("Kernel Registry Generator")
    print("=" * 50)
    
    # Scan effects folder
    effects = scan_effects_folder()
    
    if not effects:
        print("No effects found - registry will be empty")
        return 1
    
    print(f"\nFound {len(effects)} effect(s)")
    
    # Generate header file
    header_content = generate_registry_header(effects)
    with open("src/core/KernelRegistry.h", 'w') as f:
        f.write(header_content)
    print("✓ Generated: src/core/KernelRegistry.h")
    
    # Generate implementation file
    impl_content = generate_registry_implementation(effects)
    with open("src/core/KernelRegistry.cpp", 'w') as f:
        f.write(impl_content)
    print("✓ Generated: src/core/KernelRegistry.cpp")
    
    print("\nRegistry generation complete!")
    print("Add KernelRegistry.o to your Makefile to build the registry.")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
